/**
 * Guest Service Requests API
 * GET /api/guest/service-requests - Fetch all service requests for the guest
 * POST /api/guest/service-requests - Create a new service request
 */

import { NextRequest, NextResponse } from 'next/server';
import { requireGuest } from '@/lib/auth/middleware';
import { isSalesforceEnabled } from '@/lib/workato/feature-flags';
import { getSalesforceClient } from '@/lib/workato/config';
import { executeQuery, executeQueryOne, executeUpdate, generateId, formatDate } from '@/lib/db/client';
import { mapServiceRequest } from '@/lib/db/mappers';
import { ServiceRequestRow, UserRow, ServiceRequestType, Priority } from '@/types';
import { ValidationError, NotFoundError, ExternalServiceError } from '@/lib/errors';
import { createErrorResponse } from '@/lib/errors/api-response';
import { WorkatoClient } from '@/lib/workato/client';
import { generateIdempotencyToken } from '@/lib/utils/idempotency';

/**
 * GET /api/guest/service-requests
 * Fetch all service requests for the authenticated guest
 * Optionally enriches with Salesforce Case data if Case ID exists
 */
export async function GET(request: NextRequest) {
  try {
    const session = await requireGuest(request);
    
    if (isSalesforceEnabled()) {
      // Use Salesforce via Workato
      const client = getSalesforceClient();
      const requests = await client.searchServiceRequests({ guest_id: session.userId });
      
      return NextResponse.json({ requests });
    } else {
      // Use local database (legacy behavior)
      const requestsQuery = `
        SELECT * FROM service_requests 
        WHERE guest_id = ? 
        ORDER BY created_at DESC
      `;
      const requestRows = executeQuery<ServiceRequestRow>(requestsQuery, [session.userId]);
      const requests = requestRows.map(mapServiceRequest);
      
      // Optionally enrich with Salesforce data if Case IDs exist
      const workatoClient = new WorkatoClient();
      const enrichedRequests = await Promise.all(
        requests.map(async (request) => {
          if (request.salesforceTicketId) {
            try {
              const caseResponse = await workatoClient.getCase(request.salesforceTicketId);
              if (caseResponse.success && caseResponse.data) {
                return {
                  ...request,
                  salesforceData: {
                    caseNumber: caseResponse.data.caseNumber,
                    status: caseResponse.data.status,
                    createdDate: caseResponse.data.createdDate,
                  },
                };
              }
            } catch (error) {
              // Continue without Salesforce data if fetch fails
              console.warn(`Failed to fetch Salesforce Case ${request.salesforceTicketId}:`, error);
            }
          }
          return request;
        })
      );
      
      return NextResponse.json({ requests: enrichedRequests });
    }
    
  } catch (error) {
    return createErrorResponse(error, 'GET /api/guest/service-requests');
  }
}

/**
 * POST /api/guest/service-requests
 * Create a new service request with Salesforce Case integration
 */
export async function POST(request: NextRequest) {
  try {
    const session = await requireGuest(request);
    const body = await request.json();
    
    // Validate input
    const { type, priority, description } = body;
    
    if (!type || !priority || !description) {
      throw new ValidationError('Type, priority, and description are required');
    }
    
    // Validate type
    const validTypes: ServiceRequestType[] = ['housekeeping', 'room_service', 'maintenance', 'concierge'];
    if (!validTypes.includes(type)) {
      throw new ValidationError('Invalid service request type');
    }
    
    // Validate priority
    const validPriorities: Priority[] = ['low', 'medium', 'high'];
    if (!validPriorities.includes(priority)) {
      throw new ValidationError('Invalid priority');
    }
    
    // Get guest details
    const guestQuery = `SELECT * FROM users WHERE id = ?`;
    const guest = executeQueryOne<UserRow>(guestQuery, [session.userId]);
    
    if (!guest || !guest.room_number) {
      throw new NotFoundError('Guest or room');
    }
    
    if (isSalesforceEnabled()) {
      // Use Salesforce via Workato
      const client = getSalesforceClient();
      
      // Split guest name into first and last name
      const nameParts = guest.name.split(' ');
      const firstName = nameParts[0] || '';
      const lastName = nameParts.slice(1).join(' ') || nameParts[0] || '';
      
      const serviceRequest = await client.createServiceRequest({
        // Token will be auto-generated by Salesforce client
        guest_email: guest.email,
        guest_first_name: firstName,
        guest_last_name: lastName,
        room_number: guest.room_number,
        type,
        priority,
        description,
      });
      
      return NextResponse.json({
        success: true,
        request: serviceRequest,
      }, { status: 201 });
    } else {
      // Use local database (legacy behavior with optional Salesforce Case integration)
      let salesforceTicketId: string | undefined;
      let correlationId: string | undefined;
      
      try {
        // Check for existing open cases for this room and type to avoid duplicates
        const existingRequests = executeQuery<ServiceRequestRow>(
          `SELECT * FROM service_requests 
           WHERE room_number = ? 
           AND type = ? 
           AND status IN ('pending', 'in_progress')
           AND description = ?
           ORDER BY created_at DESC
           LIMIT 1`,
          [guest.room_number, type, description]
        );
        
        // If there's an existing open request with the same description, reuse its ticket ID
        if (existingRequests.length > 0 && existingRequests[0].salesforce_ticket_id) {
          salesforceTicketId = existingRequests[0].salesforce_ticket_id;
          console.log(`Reusing existing Salesforce ticket ${salesforceTicketId} for similar request`);
        } else {
          // Create new case only if no existing open case found
          const workatoClient = new WorkatoClient();
          const caseResponse = await workatoClient.createCase({
            type,
            guestName: guest.name,
            roomNumber: guest.room_number,
            priority,
            description,
          });
          
          correlationId = caseResponse.correlationId;
          
          if (caseResponse.success && caseResponse.data) {
            salesforceTicketId = caseResponse.data.id;
          } else {
            console.error('Workato API error:', caseResponse.error);
          }
        }
      } catch (workatoError) {
        // Continue even if Workato fails - graceful degradation
        console.warn('Failed to call Workato API, continuing without ticket ID:', workatoError);
      }
      
      // Create service request in database
      const requestId = generateId();
      const idempotencyToken = generateIdempotencyToken();
      const now = formatDate(new Date());
      
      executeUpdate(
        `INSERT INTO service_requests (
          id, guest_id, room_number, type, priority, description, status, salesforce_ticket_id, idempotency_token, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [requestId, session.userId, guest.room_number, type, priority, description, 'pending', salesforceTicketId || null, idempotencyToken, now]
      );
      
      // Fetch the created request
      const createdRequest = executeQueryOne<ServiceRequestRow>(
        `SELECT * FROM service_requests WHERE id = ?`,
        [requestId]
      );
      
      if (!createdRequest) {
        throw new ValidationError('Failed to create service request');
      }
      
      return NextResponse.json({
        success: true,
        request: mapServiceRequest(createdRequest),
        idempotency_token: idempotencyToken, // Include for tracking
        correlationId, // Include correlation ID for debugging
      }, { status: 201 });
    }
    
  } catch (error) {
    return createErrorResponse(error, 'POST /api/guest/service-requests');
  }
}
